{
  "python": "Python reference on high-level comprehensions: Comprehensions build collections by transforming and filtering items, optionally over multiple loops. Forms: list [expr for x in xs if cond], set {expr for x in xs if cond}, dict {k:v for x in xs if cond}, generator (expr for x in xs if cond). Common patterns: 1) Map: 'for each x in S compute f(x)' -> [f(x) for x in S]. 2) Filter: 'all x in S such that P(x)' -> [x for x in S if P(x)]. 3) Map+Filter: 'for x in S with P(x) produce g(x)' -> [g(x) for x in S if P(x)]. 4) Conditional: 'a(x) if P(x) else b(x)' -> [a(x) if P(x) else b(x) for x in S]. 5) Nested loops: 'all pairs (x,y) in A,B' -> [(x,y) for x in A for y in B]. 6) Flatten: 'flatten list of lists LL' -> [x for sub in LL for x in sub]. 7) Zipping: 'pair items from A and B' -> [(a,b) for a,b in zip(A,B)]. 8) Sets: 'unique lowercased words' -> {w.lower() for w in words}. 9) Dicts: 'map each x to f(x)' -> {x:f(x) for x in S}, 'invert dict d' -> {v:k for k,v in d.items()}. 10) 2D: 'identity matrix' -> [[1 if i==j else 0 for j in range(n)] for i in range(n)]. Aggregations: 'sum of squares for even numbers' -> sum(x*x for x in nums if x%2==0). Guidelines: avoid side effects, prefer simple readable forms, filter before heavy transforms. Templates: all X with P -> [x for x in S if P(x)], transform -> [F(x) for x in S], flatten -> [x for sub in LL for x in sub], map key->value -> {K(x):V(x) for x in S], stream -> (R(x) for x in S if P(x)).",
  "datalog": "Datalog reference: Datalog expresses logic as facts and rules. A fact asserts something true, like parent(alice,bob). A rule defines when something holds: head :- body1, body2, ... meaning 'head is true if all body conditions are true'. Variables are capitalized, constants are lowercase. Each rule is a logical implication evaluated over all possible substitutions.\n\nCore idea: derive new facts from known ones.\nExample (ancestry):\nparent(alice,bob).\nparent(bob,carol).\nancestor(X,Y) :- parent(X,Y).  // base case\nancestor(X,Y) :- parent(X,Z), ancestor(Z,Y).  // recursive case\nThis defines a transitive closure: X is an ancestor of Y if there is a chain of parent relations linking them.\n\nOther patterns:\n1) Direct relation: 'A is B's parent' -> parent(a,b).\n2) Derived relation: 'X is grandparent of Y if X is parent of Z and Z is parent of Y' -> grandparent(X,Y) :- parent(X,Z), parent(Z,Y).\n3) Join: 'X is related to Y through Z' -> related(X,Y) :- left(X,Z), right(Z,Y).\n4) Filtering: 'X is valid if registered and not banned' -> valid(X) :- registered(X), not banned(X).\n5) Aggregation: 'count children per parent' -> child_count(P, count<C>) :- parent(P,C).\n\nHigh-level mapping:\n- 'If condition then conclusion' -> conclusion :- condition.\n- 'A depends on B and C' -> A :- B, C.\n- 'A unless B' -> A :- not B.\n- 'All pairs (X,Y) satisfying relation R' -> R(X,Y) :- cond(X,Y).\n\nDatalog is declarative: it specifies what is true, not how to compute it. Transitive closure patterns (like ancestor or reachable) are common and illustrate recursion and inference through repeated rule application."
}